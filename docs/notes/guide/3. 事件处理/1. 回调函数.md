---
title: 回调函数
createTime: 2025/02/07 11:24:25
permalink: /guide/awamzkai/
---

## 回调函数机制

NcatBot 采用**回调函数**机制来完成事件上报. 回调函数是用户自定义的**异步函数**. 当对应事件发生时, NcatBot 会调用这些函数, 并将事件相关信息作为参数传递.

## 异步回调函数

NcatBot 要求所有回调函数都是**异步函数**.

::: code-tabs
@tab python
```python
@bot.private_event()
async def on_private_message(msg: PrivateMessage):
    _log.info(msg)
    if msg.raw_message == '测试':
        await bot.api.post_private_msg(msg.user_id, text="NcatBot 测试成功喵~")
```
:::

Ncatbot 对回调函数的名字没有要求, 但按照习惯一般命名为 `on_[事件类型]`.

::: details 对初学者的提醒
什么是异步, 为什么回调函数需要定义为异步?

1. 什么是异步? 
   一般来说, 程序是从上到下依次执行的. 下一步操作需要等待上一步操作完成, 这种方式叫做同步. 而异步允许在等待某个操作完成的同时继续执行其他任务. 例如有两个群的消息, 异步可以让程序无须等待上一次处理完成便开始处理下一次. 比如请求 AI 回复时会有很长的延迟, 那么异步可以让程序在等待 AI 回复的同时继续处理其他消息, 提高程序的效率.

2. 为什么 NcatBot 的回调函数必须定义为异步?

    1. 事件触发的机制
    
        NcatBot 的事件机制是以异步方式实现的. 当事件发生时, 程序会通过**异步调用**的方式触发相应的回调函数. 如果回调函数不是异步的, 那么会直接出现运行时错误.

    2. 与异步 API 的配合.
   
        NcatBot 的 API (如 bot.api.post_private_msg) 通常也是异步的. 这些 API 需要通过 await 关键字来调用, 以便等待异步操作完成. **同步函数中不允许使用 `await` 关键字调用异步函数**, 因此回调函数必须被定义为异步函数.

3. 什么是 `await` 关键字?
   
   - `await` 关键字用于显式等待异步操作完成. 例如, 当你调用 `bot.api.post_private_msg` 时, 会返回一个 `Future` 对象, 你需要使用 `await` 关键字来等待这个 `Future` 对象完成, 也就是等待 `post_private_msg` 操作完成.
  
   - `await asyncfun()` 的结果是 `asyncfun()` 的返回值, 如果你是新手彭彭建议你永远加上括号以保证运算顺序正确: `result = (await asyncfun())`.

   - `await` 关键字只能在异步函数(也就是定义为 `async def` 的函数)中使用, 否则会报错.

:::

> 线程安全提醒猫: 异步千万条, 安全第一条, 线程不安全, 数据两行泪.

务必注意回调函数的线程安全(初学者别管了, 你写出来的在出 bug 之前都是线程安全的).

## 回调函数注册修饰器

**回调函数**需要通过**回调函数注册修饰器**来定义.

**回调函数注册修饰器**是 `BotClient` 类的成员函数, 通过使用修饰器, 用户自定义的回调函数会和对应的 bot 实例绑定, 对应 bot 实例发生对应事件时, 会调用绑定的的回调函数.

::: code-tabs
@tab python
```python
@bot.private_event()
async def on_private_message(msg: PrivateMessage):
    _log.info(msg)
    if msg.raw_message == '测试':
        await bot.api.post_private_msg(msg.user_id, text="NcatBot 测试成功喵~")
```
:::

`bot` 是一个 `BotClient` 实例, 使用 `bot.private_event()` 作为修饰器来注册回调函数.

回调函数注册修饰器列表请查阅 [事件上报](./2.%20事件上报.md).

::: details 对初学者的提醒
装饰器是一种非常强大的功能, 它允许你在不修改原有函数代码的情况下, 动态地增加函数的功能. 装饰器本质上是**一个返回函数的函数**. 为了更好地理解装饰器的原理, 我们结合前面提到的示例来详细解释:

1. 装饰器的实现
    1. 定义装饰器函数:
        装饰器函数接收一个函数作为参数.
        在装饰器内部, 定义一个嵌套函数 (通常称为 wrapper), 这个嵌套函数会增强或修改原函数的行为.
    2. 返回嵌套函数:
        装饰器函数返回嵌套函数, 这样原函数就被替换为嵌套函数.
    3. 使用装饰器:
        使用 @装饰器名称 语法, 将装饰器应用到目标函数上.

2. 装饰器的本质

相应的代码如下:

```python
class BotClient:
    def __init__(self, use_ws=True):
        # 喵~

    def group_event(self, types=None):
        def decorator(func):
            self._group_event_handlers.append((func, types))
            return func

        return decorator
```

于是:

```python
@bot.group_event()
async def on_group_message(msg: GroupMessage):
    _log.info(msg)
```

的本质是: `on_group_message = bot.group_event()(on_group_message)`, 等价于执行 `bot._group_event_handlers.append((on_group_message, None))`.

可选参数 `types` 的作用可以查阅[事件上报](../3.%20事件处理/事件上报.md)部分的文档了解.


*"装饰器" 和 "修饰器" 都是 "decorator" 的译名, 有一部分是彭彭手写的, 一部分是 AI 写的, 所以出现了差异喵~*
:::


