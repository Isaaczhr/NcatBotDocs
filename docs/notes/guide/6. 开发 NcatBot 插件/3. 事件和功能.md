---
title: 事件和功能
createTime: 2025/03/06 10:07:54
permalink: /guide/pasevent/
---

## 事件

### 事件对象

事件是基本的可处理对象, 一个事件由 `ncatbot.plugin.event.Event` 类表示.

`Event` 类主要包含两个成员变量

- `data: dict` 事件携带的数据
- `type: str` 事件类型列表

### 事件类型

事件在被发布时会携带上事件类型, 事件类型用于订阅和处理事件.

事件类型命名规范为 `[插件名].[事件名]`.

四大基本事件 (群聊消息, 私聊消息, 请求消息, 通知消息) 的事件名封装如下:

- `ncatbot.utils.literals.OFFICIAL_GROUP_MESSAGE_EVENT = "ncatbot.group_message_event"`
- `ncatbot.utils.literals.OFFICIAL_PRIVATE_MESSAGE_EVENT = "ncatbot.private_message_event"`
- `ncatbot.utils.literals.OFFICIAL_REQUEST_EVENT = "ncatbot.request_event"`
- `ncatbot.utils.literals.OFFICIAL_NOTICE_EVENT = "ncatbot.notice_event"`

插件也可以自行发布事件, 具体请继续阅读.

### 事件传播

事件沿事件总线传播, 处理事件时可以主动停止事件传播或者添加事件处理结果, 相关函数:

- `Event.stop_propagation()`
- `Event.add_result(result)`

## 事件总线

咕咕咕.

## 订阅事件

### 使用兼容回调函数注册器

如果要实现 `BotClient` 到插件的迁移, 可以使用兼容注册器, 详见 [了解 NcatBot 插件](1.%20了解%20NcatBot%20插件.md).

### 根据事件名称订阅事件

可以使用精确匹配或者正则匹配==按照事件类型==订阅事件, 如下例.

```python
class MyPlugin(BasePlugin):
    async def on_load(self):
        # 支持正则匹配,re:前缀
        self.register_handler("re:test\.", self.handle_test) # 订阅 test 插件发布的所有事件
        self.register_handler("exact.match", self.handle_exact) # 订阅 exact 插件发布的 match 事件

    async def handle_test(self, event: Event):
        print(f"正则匹配处理器: {event.data}")

    async def handle_exact(self, event: Event):
        print(f"精确匹配处理器: {event.data}")
```

### 事件回调函数

订阅事件时需要指定一个回调函数, 回调函数需要接受一个 `Event` 类型的参数, 并且必须定义为==异步函数==.

在事件回调函数中可以对事件进行处理, 也可以调用 `Event` 的方法停止事件传播或者添加事件处理结果.

## 发布事件

在 `BasePlugin` 上下文中任意位置均可发布事件.

事件分为同步和异步, 同步事件会优先处理并迅速返回结果, 异步事件将会挂到异步事件循环中处理, ==如果可能请一定使用异步事件, 同步事件未经测试不稳定==

事件的处理结果(如果有), 应该使用 `Event.add_result(result)` 在回调函数中添加.

==请务必严格按照 `[插件名].[事件名]` 的格式填写事件类型.==

```python
class MyPlugin(BasePlugin):
    def some_func(self):
        event = Event("MyPlugin.event", {"message": "hello"})
        await self.event_bus.publish_async(event)  # 异步发布不等待结果
        results = self.event_bus.publish_sync(event)  # 同步等待结果
```

## 功能

功能是对事件发布和处理的进一步封装, 使用功能可以方便快捷的接入 NcatBot 的权限管理机制.

功能的运作对象是==消息事件==, 只有群聊和私聊消息能够触发功能.

### 注册功能

以下函数用于注册功能:

```python
def register_default_func(
    self,
    handler: Callable[[BaseMessage], Any],
    permission: PermissionGroup = PermissionGroup.USER.value,
):
def register_user_func(
        self,
        name: str,
        handler: Callable[[BaseMessage], Any],
        filter: Callable[[Event], bool] = None,
        raw_message_filter: Union[str, re.Pattern] = None,
        permission_raise: bool = False,
):
def register_admin_func(...)
```

#### `register_default_func`

注册一个默认功能, 如果一条消息没有触发==默认功能所在插件的任何其它功能, 也没有触发内置功能==, 则会触发默认功能.

- `handler`: 功能处理函数, 接受一个 `BaseMessage` 类型的参数, 必须定义为==异步函数==.
- `permission`: 功能权限, 默认为 `user` 级别.

#### `register_user_func`

注册一个用户功能, 如果能满足触发条件则触发该功能.

- `name`: 功能名称, 用于建立权限结构, 该功能的权限路径为 `<plugin_name>.<name>`.
功能.
- `raw_message_filter`: 功能触发条件, 接受一个 `str` 或者 `re.Pattern` 类型的参数, 必须定义为==同步函数==, 如果消息==前缀和指定的 `str` 值一致==, 或者 ==`re.match(raw_message_filter, message.raw_message)` 返回 `True`==(正则表达式从头匹配匹配成功), 则触发该功能.
- `filter`: 功能触发条件, 接受一个 `Event` 类型的参数, 必须定义为==同步函数==, 返回一个 `bool` 值, 如果为 `True` 则触发该功能.
- `permission_raise`: 是否针对群聊提权, 如果 `user_id` (消息发送者 QQ 号) 为 admin 级别及以上权限, 则临时提升消息来源群聊的权限为 `root`. 私聊被分在一个特殊的群组, 权限为 `root`.

#### `register_admin_func`

注册一个管理员功能, 如果能满足触发条件则触发该功能.

### 注册配置项

NcatBot 插件系统内置了 `/cfg` 功能, 用于管理插件的配置项.

配置项会在正常退出时自动保存, 下次启动时自动加载, ==会占用内置可持久化数据的 `config` 键值==.

可以通过 `BasePlugin.register_config` 注册配置项.

函数原型:

```python
def register_config(
    self, key: str, default: Any, rptr: Callable[[str], Any] = None
):
```

- `key`: 配置项键名, 用于建立权限结构, 修改配置项所需的权限路径为 `cfg.<plugin_name>.<key>`.
- `default`: 配置项默认值.
- `rptr`: 配置项值转换函数, 接受一个 `str` 类型的参数, 必须定义为==同步函数==, 返回一个 `Any` 类型的值. 如果留空则不做转换默认为 `str` 类型.

### 权限机制

#### 权限触发条件

权限只对==功能==生效.

群组和用户的权限独立, 当且仅当用户权限和群聊权限同时满足时, 才能触发对应功能.

#### 权限分级

NcatBot 的内置权限机制包括 `user`, `admin`, `root` 三级:

- `user` 权限: 使用 `user` 级别功能, `user` 权限默认分配给所有用户
- `admin` 权限: `user` 的全部权限以及 `admin` 级别功能.
- `root` 权限: `admin` 的全部权限以及 `root` 级别功能.

#### 权限管理

内置功能中的 `sm` 和 `acs` 可以用于管理权限.

权限相关的文件将会自动保存到 `data/U_access.json` 和 `data/G_access.json` 文件中, 重启后自动加载.

可以格式化两个文件后手动修改权限.

### 内置功能

NcatBot 提供了一些内置功能, 可以极大简化开发流程

#### cfg

默认为==管理员功能==, 用于修改配置文件中的配置项.

触发格式: `/cfg <plugin_name>.<cfg_name> <value>`

#### plg

默认为==管理员功能==, 用于查看已经安装的插件.

触发格式: `/plg`

#### sm

默认为==ROOT功能==, 用于设置管理员.

触发格式: `/sm <user_id>`

如果 `user_id` 已经具有管理员权限, 则会取消其管理员权限.

BOT 的回复消息会反应管理员权限的状态

#### acs

默认为==管理员功能==, 用于细致化修改权限.

触发格式: `/acs [-g] [ban]/[grant] <number> <path>`

- `[-g]`: 可选, 用于明确 `<number>` 是否为群聊.
- `[ban]/[grant]`: 指明是授予黑名单还是白名单, 授予黑名单时同时清除白名单.
- `<number>`: 群聊号或者用户 QQ 号.
- `<path>`: 权限路径, 一般格式为 `<plugin_name>.<func_name>`

`/acs` 无法操作某些特定的权限路径, 也无法操作具有 `/acs` 权限的用户. 

## 参考案例

### 介绍

LLM_API 插件不直接提供大语言模型对话服务, 而是提供基于事件的对话接口和基本配置服务.

### 配置项

使用 NcatBot 的内置配置项功能, 三个核心配置项如下:

- api: `/cfg LLM_API.api <your api>` api-key。
- url: `/cfg LLM_API.url <your url>` 基准 url。
- model: `/cfg LLM_API.model <your model>` 模型名。

例如 [Kimi](https://platform.moonshot.cn/docs/guide/migrating-from-openai-to-kimi#%E5%85%B3%E4%BA%8E-api-%E5%85%BC%E5%AE%B9%E6%80%A7):

```
url: https://api.moonshot.cn/v1
model: moonshot-v1-8k
api: <KEY>
```

### 事件

通过 `LLM_API.main` 事件触发调用 LLM 的服务, `Event` 参数的 data 部分为 LLM 输入参数, 事件的处理结果为 LLM 的回复.

`data` 的构造如下:

```
{
    "history": [
        {
            "role": "system",
            "content": "系统提示内容"
        },
        {
            "role": "user",
            "content": "用户输入内容"
        },
    ], # 提示信息
    "max_tokens": 4096, # 最大长度
    "temperature": 0.7 # 温度,
}
```

`result` 的构造如下:

```
{
    "text": "回复内容",
    "status": "状态码" # 200 表示成功, 其他表示失败
    "error": "错误信息" # 
}
```

### 测试

管理员权限可以输入 `/tllma` 触发大模型测试事件.

### 源代码

```python
from ncatbot.plugin import BasePlugin, CompatibleEnrollment, Event
from ncatbot.core.message import GroupMessage, PrivateMessage
import asyncio
import httpx
import openai
from concurrent.futures import ThreadPoolExecutor

bot = CompatibleEnrollment  # 兼容回调函数注册器

DEFAULT_URL = "url"
DEFAULT_API = "api"
DEFAULT_MODEL = "model"

class LLM_API(BasePlugin):
    name = "LLM_API" # 插件名称
    version = "0.0.1" # 插件版本

    async def on_load(self):
        print(f"{self.name} 插件已加载")
        print(f"插件版本: {self.version}")
        self.register_config("url", DEFAULT_URL)
        self.register_config("api", DEFAULT_API)
        self.register_config("model", DEFAULT_MODEL) # 注册三个配置项
        self.register_handler("LLM_API.main", self.main) # 注册事件(Event)处理器
        self.register_admin_func("test", self.test, raw_message_filter="/tllma", permission_raise=True) # 注册一个管理员功能, 需要提权以便在普通群聊中触发
    
    async def test(self, message: PrivateMessage):
        # 通过事件调用插件提供的接口(其它插件也可以通过发布事件调用这个接口)
        result = (await self.publish_async(Event("LLM_API.main", {
                "history": [
                {
                    "role": "system",
                    "content": "系统提示内容"
                },
                {
                    "role": "user",
                    "content": "用户输入内容"
                },
            ], # 提示信息
            "max_tokens": 4096, # 最大长度
            "temperature": 0.7 # 温度, 0-1, 越大越随机
        })))[0]
        await message.reply(text=result["text"] + result['error'])        
        
    async def main(self, event: Event):
        data = event.data
        url = self.data['config']["url"]
        api = self.data['config']["api"]
        model = self.data['config']["model"]
        
        if url == DEFAULT_URL or api == DEFAULT_API or model == DEFAULT_MODEL:
            event.add_result({
                "text": "",
                "status": 501,
                "error": "配置项错误"
            })
            return
        
        # 连接大预言模型的代码略去, 这里返回一个你好
        event.add_result({
            "text": "你好",
            "status": 200,
            "error": ""
        })
    
    async def on_unload(self):
        print(f"{self.name} 插件已卸载")
```
