---
title: 示例代码解析——NcatBot 是如何运作的 
createTime: 2025/02/08 10:07:54
permalink: /guide/k4qzlkxe/
---

TODO:
 
事件上报(handler)部分的链接还没插.

事件处理(handler)部分的链接还没插.

配置项(config)部分的链接还没插.

## 代码解析

在这一部分, 我们会拆解示例代码, 以帮助你理解 NcatBot 是如何运作的.

### 导入部分

::: code-tabs
@tab python
```python
from ncatbot.client import BotClient
from ncatbot.message import GroupMessage, PrivateMessage

from ncatbot.logger import get_log
from ncatbot.config import config
```
:::

导入部分分为 4 段, 分别是:

1. 导入 `BotClient` 类, 用于创建一个 bot 实例, NcatBot 的所有接口和功能都封装在这个类中.
2. 导入 `GroupMessage` 和 `PrivateMessage` 类, 用于**类型注解**, 方便使用 IDE 的代码补全功能.
3. 导入 `get_log` 函数, 用于获取日志实例, 输出**日志信息**方便调试.
4. 导入 `config` 模块, 用于配置 bot 的相关参数.

### 准备部分

::: code-tabs
@tab python
```python

_log = get_log()

config.set_bot_uin("123456") # 设置 bot qq 号
config.set_ws_uri("localhost:3001") # 设置 napcat websocket server 地址

bot = BotClient()
```
:::

准备部分分为**有顺序的** 3 部分, 分别是:

1. 获取日志实例 `_log`, 输出**日志信息**方便调试.
2. 设置 bot 的 qq 号和 napcat websocket server 地址.
3. 创建一个 bot 实例 `bot`.

特别提醒, `config` 是一个全局变量, 用于配置 bot 的相关参数, 所以必须在**创建 bot 实例之前**设置.

关于更多配置项和配置项指定的其它方式, 请查阅[配置项](xxx)

### 事件回调函数部分

::: code-tabs
@tab python
```python
@bot.group_event()
async def on_group_message(msg: GroupMessage):
    _log.info(msg)

@bot.private_event()
async def on_private_message(msg: PrivateMessage):
    _log.info(msg)
    if msg.raw_message == '测试':
        await bot.api.post_private_msg(msg.user_id, text="NcatBot 测试成功喵~")
```
:::

使用 decorator `@bot.group_event()` 和 `@bot.private_event()` 来注册事件**回调函数**, 用于处理事件.

函数名可以随意取, 但按照习惯会以 `on_[事件类型]` 命名, 例如 `on_group_message` 和 `on_private_message`.

**回调函数**会在相应的事件发生后被调用, 用于应对这些事件, 例如这里的例子, 当用户在私聊中**发送任意消息**时, 都会调用 `on_private_message` 函数, 并将 `msg` 作为参数传入.

在 `on_private_message` 中, 编写了一些逻辑, 这里的逻辑是如果文本为 `测试` 时, 向用户发送一条 `NcatBot 测试成功喵~` 的消息.

这里只列出了两个基础的**回调函数注册修饰器**: `@bot.group_event()` 和 `@bot.private_event()`, 关于更多修饰器和修饰器的更多用法, 请查阅[事件上报](xxx).

关于**回调函数**的参数 `msg`, 请查阅[事件处理](xxx).

*注意区分: **回调函数注册修饰器** 和 **回调函数**, 前者是 NcatBot 提供的用于注册回调函数的**修饰器函数**, 后者是由你编写的用于处理上报事件的函数.*

::: details 对初学者的提醒
装饰器是一种非常强大的功能, 它允许你在不修改原有函数代码的情况下, 动态地增加函数的功能. 装饰器本质上是**一个返回函数的函数**. 为了更好地理解装饰器的原理, 我们结合前面提到的示例来详细解释:

1. 装饰器的实现
    1. 定义装饰器函数:
        装饰器函数接收一个函数作为参数.
        在装饰器内部, 定义一个嵌套函数 (通常称为 wrapper), 这个嵌套函数会增强或修改原函数的行为.
    2. 返回嵌套函数:
        装饰器函数返回嵌套函数, 这样原函数就被替换为嵌套函数.
    3. 使用装饰器:
        使用 @装饰器名称 语法, 将装饰器应用到目标函数上.

2. 装饰器的本质

相应的代码如下:

```python
class BotClient:
    def __init__(self, use_ws=True):
        # 喵~

    def group_event(self, types=None):
        def decorator(func):
            self._group_event_handler = (func, types) # 重置事件处理函数 _group_event_handler 为你的回调函数
            return func

        return decorator
```

于是:

```python
@bot.group_event()
async def on_group_message(msg: GroupMessage):
    _log.info(msg)
```

的本质是: `on_group_message = bot.group_event()(on_group_message)`, 等价于执行 `bot._group_event_hanlder = (on_group_message, None)`.

可选参数 `types` 的作用可以查阅[事件上报]()部分的文档了解.


*"装饰器" 和 "修饰器" 都是 "decorator" 的译名, 有一部分是彭彭手写的, 一部分是 AI 写的, 所以出现了差异喵~*
:::

### 运行部分

::: code-tabs
@tab python
```python
if __name__ == '__main__':
    bot.run(False)
```
:::

`bot.run()` 有一个可选的参数 `reload`, 默认为 `False`.

设置为 `True` 时, NcatBot 将**不会检查**本地的 NapCat 配置情况.

NcatBot 默认会在本地运行 NapCat 服务, 如果你要配置远程的 NapCat 服务, 请将 `ws_uri` 和 `hp_uri` 设置为远端 NapCat 服务的地址, 并将 `reload` 设置为 `True`.

额外提醒, NapCat 服务如果对公网开放, **一定要设置 Token**.

::: details 对初学者的提醒
在 Python 中, 每个模块都有一个特殊的内置变量 `__name__`. 它的值取决于模块是如何被运行的:

- 如果模块是被直接运行的 (例如, 你直接运行一个脚本文件), `__name__` 的值会被设置为 `'__main__'`.
- 如果模块是被其他模块导入的 (例如, 你在其他脚本中用 `import` 导入了这个模块), `__name__` 的值会是模块的名称(通常是文件名, 不带 `.py` 后缀).

*使用 `import xxx` 或者  `from xxx import yyy` 时, `xxx` 文件中的**所有代码**都会被执行一遍.*

例如, 你复制的示例代码就是被 **直接运行** 的, 而代码中导入的 `ncatbot.client` 等代码就是**被其它模块导入** 的.

尽管在这里 `if __name__ == '__main__':` 并不是必须的, 因为 `main.py` 一定会被直接运行, 但这不失为一种良好的编程习惯.
:::